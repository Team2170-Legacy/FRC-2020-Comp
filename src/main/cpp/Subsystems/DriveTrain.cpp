// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/DriveTrain.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveTrain::DriveTrain() : frc::Subsystem("DriveTrain"),
    kWheelDiameter(frc::Preferences::GetInstance()->GetDouble("Wheel Diameter", 6.0)),
    kP(frc::Preferences::GetInstance()->GetDouble("Drive kP", 0.0)),
    kFF(frc::Preferences::GetInstance()->GetDouble("Drive kFF", 180.0e-6)),
    maxFeetPerSec(frc::Preferences::GetInstance()->GetDouble("Drive FPS", 18.0)),
    maxAccelPerSec(frc::Preferences::GetInstance()->GetDouble("Drive Accel FPS^2", 10.0)) {


    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
compressor.reset(new frc::Compressor(0));
AddChild("Compressor", compressor);

powerDistributionPanel.reset(new frc::PowerDistributionPanel(0));
AddChild("PowerDistributionPanel", powerDistributionPanel);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Set follow motors to leaders
    m_leftFollow.Follow(m_leftLead);
    m_rightFollow.Follow(m_rightLead);

    // Set encoder converting factors 
    m_leftEncoder.SetPositionConversionFactor((M_PI * kWheelDiameter / (kGearRatio * 60.0 * 12.0)));
    m_rightEncoder.SetPositionConversionFactor((M_PI * kWheelDiameter / (kGearRatio * 60.0 * 12.0)));
    m_leftEncoder.SetPositionConversionFactor((M_PI * kWheelDiameter) / (kGearRatio * 12.0));
    m_rightEncoder.SetPositionConversionFactor((M_PI * kWheelDiameter) / (kGearRatio * 12.0));

    // Set min/max power
    m_pidControllerL.SetOutputRange(kMinOutput, kMaxOutput);
    m_pidControllerR.SetOutputRange(kMinOutput, kMaxOutput);
    m_pidControllerL.SetSmartMotionMaxVelocity(maxFeetPerSec);
    m_pidControllerR.SetSmartMotionMaxVelocity(maxFeetPerSec);
    m_pidControllerL.SetSmartMotionMaxAccel(maxAccelPerSec);
    m_pidControllerR.SetSmartMotionMaxAccel(maxAccelPerSec);
    
    // Set kFF and kP ( after tuning, since gains have been already been determined )
    m_pidControllerL.SetP(kP);
    m_pidControllerR.SetP(kP);

    m_pidControllerL.SetFF(kFF);
    m_pidControllerR.SetFF(kFF);


    
}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveTrain::Periodic() {
    // Put code here to be run every loop
    m_odometry.Update(frc::Rotation2d(units::degree_t(GetHeading())),
                        units::meter_t(m_leftEncoder.GetPosition()),
                        units::meter_t(m_rightEncoder.GetPosition()));

}

void DriveTrain::VelocityArcadeDrive(double xSpeed, double zRotation, bool squaredInputs)
{
    double moveValue = xSpeed;
    double rotateValue = zRotation;

    if(moveValue > 0.0 && moveValue < 0.05){
        moveValue = 0.0;
    } else if(moveValue < 0.0 && moveValue > -0.05){
        moveValue = 0.0;
    } 

    if (fabs(rotateValue) < 0.01) {
        rotateValue = 0.0;
    }

    static bool reported = false;
    if (!reported)
    {
        HAL_Report(HALUsageReporting::kResourceType_RobotDrive, 4,
                   HALUsageReporting::kRobotDrive_ArcadeStandard);
        reported = true;
    }

    // local variables to hold the computed PWM values for the motors
    double leftMotorOutput;
    double rightMotorOutput;

    // LeftMove and leftRotate limits to +-1.0
    if (moveValue > 1.0)
    {
        moveValue = 1.0;
    }
    if (moveValue < -1.0)
    {
        moveValue = -1.0;
    }
    if (rotateValue > 1.0)
    {
        rotateValue = 1.0;
    }
    if (rotateValue < -1.0)
    {
        rotateValue = -1.0;
    }

    // square the inputs (while preserving the sign) to increase fine control
    // while permitting full power
    if (squaredInputs)
    {
        moveValue = std::copysign(moveValue * moveValue, moveValue);
        rotateValue = std::copysign(rotateValue * rotateValue, rotateValue);
    }

    if (moveValue > 0.0)
    {
        if (rotateValue > 0.0)
        {
            leftMotorOutput = moveValue - rotateValue;
            rightMotorOutput = std::max(moveValue, rotateValue);
        }
        else
        {
            leftMotorOutput = std::max(moveValue, -rotateValue);
            rightMotorOutput = moveValue + rotateValue;
        }
    }
    else
    {
        if (rotateValue > 0.0)
        {
            leftMotorOutput = -std::max(-moveValue, rotateValue);
            rightMotorOutput = moveValue + rotateValue;
        }
        else
        {
            leftMotorOutput = moveValue - rotateValue;
            rightMotorOutput = -std::max(-moveValue, -rotateValue);
        }
    }

    double leftMotorSpeed = leftMotorOutput * maxFeetPerSec;
    double rightMotorSpeed = rightMotorOutput * -maxFeetPerSec;

    // Send setpoints to pid controllers
    m_pidControllerL.SetReference(leftMotorSpeed, rev::ControlType::kSmartVelocity);
    m_pidControllerR.SetReference(rightMotorSpeed, rev::ControlType::kSmartVelocity);
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveTrain::ResetEncoders() {
    m_leftEncoder.SetPosition(0.0);
    m_rightEncoder.SetPosition(0.0);
}

void DriveTrain::ResetOdometry(frc::Pose2d pose) {
    ResetEncoders();
    m_odometry.ResetPosition(pose,
                frc::Rotation2d(units::degree_t(GetHeading())));
}
void DriveTrain::SetMaxOutput(double maxOutput) {
    m_Drive.SetMaxOutput(maxOutput);
}

double DriveTrain::GetHeading() {
    return std::remainder(m_gyro.GetAngle(), 360) * (kGyroReverse ? -1.0 : 1.0);
}

double DriveTrain::GetTurnRate() {
    return m_gyro.GetRate() * (kGyroReverse ? -1.0 : 1.0);
}

frc::Pose2d DriveTrain::GetPose() {return m_odometry.GetPose();}
frc::DifferentialDriveWheelSpeeds DriveTrain::GetWheelSpeeds(){
    return {units::feet_per_second_t(m_leftEncoder.GetVelocity(),
    units::feet_per_second_t(m_rightEncoder.GetVelocity()))};
}
double DriveTrain::GetAverageEncoderDistance( ) {
    return(m_leftEncoder.GetPosition() + m_rightEncoder.GetPosition()) /2.0;
}























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































