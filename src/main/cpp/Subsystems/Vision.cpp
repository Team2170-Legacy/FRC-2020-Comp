// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Vision.h"

Vision::Vision() {
    auto table = nt::NetworkTableInstance::GetDefault().GetTable("limelight");
    tx = table->GetEntry("tx");
	ty = table->GetEntry("ty");
    tv = table->GetEntry("tv");
    tl = table->GetEntry("tl");
    getPipe = table->GetEntry("getpipe");
	ledMode = table->GetEntry("ledMode");
	camMode = table->GetEntry("camMode");
	setPipe = table->GetEntry("pipeline");
	snapshot = table->GetEntry("snapshot");
    distance = table->GetEntry("distance");
    distance.SetDouble(0);
    visionDrive = table->GetEntry("Vision Drive");
    visionDrive.SetBoolean(false);

    kP_Omega_Entry = table->GetEntry("Vision kP Omega");
    kI_Omega_Entry = table->GetEntry("Vision kI Omega");
    kP_Distance_Entry = table->GetEntry("Vision kP Distance");
    kI_Omega_Entry.SetDouble(kI_Omega);
    kP_Omega_Entry.SetDouble(kP_Omega);
    kP_Distance_Entry.SetDouble(kP_Distance);
}


void Vision::Periodic() {
    if (!TargetIsLocked()) {
        targetLocked = false;
        visionDriveActive = false;
        distanceToTarget = 0;
        distanceError = 0;
        angleError = 0;
        visionSpeed = 0;
        visionOmega = 0;        
    }
    else if (!visionDriveActive) {
        // calulate distance error
        optimalShootingDistance = frc::Preferences::GetInstance()->GetDouble("Optimal Shooting Distance", optimalShootingDistance);
        double distanceFromTarget = GetDistanceToPowerport();
        distance.SetDouble(distanceFromTarget);
        double distanceError =  optimalShootingDistance - distanceFromTarget;

        // get angle error
        double xAngleError = GetXAngleToTarget();

        targetLocked = true;
        distanceToTarget = distanceFromTarget;
        distanceError = distanceError;
        angleError = xAngleError;
        visionSpeed = 0;
        visionOmega = 0;        
    }
    visionLogger.WriteVisionData(targetLocked, visionDriveActive, distanceToTarget,
                                 distanceError, angleError, visionSpeed, visionOmega);
}

/**
 * @brief Checks if a target is locked. 
 * 
 * @return true when target locked
 * @return false when target not found
 */
bool Vision::TargetIsLocked() {
    return (tv.GetDouble(0) == 1);
}

/**
 * @brief Returns tx from limelight network tables
 * Should only be called if a target is locked
 * 
 * @return x-angle from target in degrees
 */
double Vision::GetXAngleToTarget() {
   return tx.GetDouble(0);
}

/**
 * @brief Calculates distance from the front bumper of robot to the powerport in ft
 * Should only be called when a powerport target is locked
 *
 * @return distance from powerport 
 */
double Vision::GetDistanceToPowerport() {
    double angleToTarget = (cameraAngle + ty.GetDouble(0)) * Deg2Rad;
    double camToPowerPortDistance  = (powerportVisionTargetHeight - cameraHeight) / tan(angleToTarget);
    return camToPowerPortDistance - cameraDistanceFromFrontBumper;
}

/**
 * @brief gets combined latency of the pipeline and image capture in ms
 * 
 * @return combined latency of the pipeline and image capture in milliseconds
 */
double Vision::GetLatency() {
    return tl.GetDouble(0) + 11;
}

/**
 * @brief Sets the LED Mode of the camera
 * 
 * @param ledModeToSet LEDMode enum value
 *
 */
void Vision::SetLEDMode(LEDMode ledModeToSet) {
    int ledModeValue = ledModeToSet;
    ledMode.SetDouble((double)ledModeValue);
}

/**
 * @brief Switches between vision processing and drive mode
 * 
 * @param visionProcessingEnabled true enables vision processing, false stops vision processing and increases exposure
 */
void Vision::SetCamMode(bool visionProcessingEnabled) {
    if (visionProcessingEnabled)
    {
        camMode.SetDouble(0);
    }
    else
    {
        camMode.SetDouble(1);
    }
}

/**
 * @brief Sets the current vision processing pipeline
 * 
 * @param pipeline the pipeline to use
 */
void Vision::SetPipeline(Pipeline pipeline) {
    int pipelineIndex = pipeline;
    setPipe.SetDouble((double)pipelineIndex);
}

/**
 * @brief Saves a snapshot to the limelight.
 * 
 */
 void Vision::TakeSnapshot() {
     snapshot.SetDouble(1);
 }

void Vision::VisionSteerInit() {
    visionDrive.SetBoolean(true);
    omegaIntegrator = 0.0;
}

std::pair<double, double> Vision::SteerToLockedTarget() {
    // Publish automove flag to true while this code is running
    visionDrive.SetBoolean(true);

    // calulate distance error
    optimalShootingDistance = frc::Preferences::GetInstance()->GetDouble("Optimal Shooting Distance", optimalShootingDistance);
    double distanceFromTarget = GetDistanceToPowerport();
    distance.SetDouble(distanceFromTarget);
    double distanceError = optimalShootingDistance - distanceFromTarget;

    // get angle error
    double angleError = GetXAngleToTarget();

    // deadband angle error
    if (angleError < angleErrorDeadband && angleError > -angleErrorDeadband)
    {
        angleError = 0;
    }
    else if (angleError > angleErrorDeadband)
    {
        angleError -= angleErrorDeadband;
    }
    else
    {
        angleError += angleErrorDeadband;
    }

    kP_Omega = kP_Omega_Entry.GetDouble(kP_Omega);
    kI_Omega = kI_Omega_Entry.GetDouble(kI_Omega);
    kP_Distance = kP_Distance_Entry.GetDouble(kP_Distance);
    double omega = 0.0;
    double speed = 0.0;

    omegaIntegrator += angleError * deltaTime;
    omega = kP_Omega * angleError;
    omega += omegaIntegrator * kI_Omega;

    if (omega > omegaLimiter)
    {
        omega = omegaLimiter;
    }
    else if (omega < -omegaLimiter)
    {
        omega = -omegaLimiter;
    }

    speed = kP_Distance * distanceError;

    // Logger variable updates
    targetLocked = true;
    visionDriveActive = true;
    distanceToTarget = distanceFromTarget;
    distanceError = distanceError;
    angleError = angleError;
    visionSpeed = speed;
    visionOmega = omega;
 
    return std::make_pair(speed, omega);
}

void Vision::VisionSteerEnd() {
    visionDrive.SetBoolean(false);
    visionDriveActive = false;
}

void Vision::EnableLogging() {
    visionLogger.VisionLogger("/home/lvuser/VisionLogs/Vision_Log" + DataLogger::GetTimestamp() + ".csv");
}

void Vision::DisableLogging() {
    visionLogger.EndSession();
}