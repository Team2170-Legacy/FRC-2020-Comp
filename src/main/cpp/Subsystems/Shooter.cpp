// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Shooter.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Shooter::Shooter() :
    kP(frc::Preferences::GetInstance()->GetDouble("Shoot kP", 0.0)),
    kFF(frc::Preferences::GetInstance()->GetDouble("Shoot kFF", 180.0e-6)),
    maxFeetPerSec(frc::Preferences::GetInstance()->GetDouble("Shoot RPM Max", 3000.0)),
    maxAccelPerSec(frc::Preferences::GetInstance()->GetDouble("Shoot Accel Max", 500.0)) {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    m_shooterEncoderLead.SetPositionConversionFactor(kGearRatio);

    m_shooterEncoderFollow.SetPositionConversionFactor(kGearRatio);

    m_shooterFollow.Follow(m_shooterLead);

    // Set min/max power
    m_pidShooterMotorLead.SetOutputRange(kMinOutput, kMaxOutput);
    m_pidShooterMotorLead.SetSmartMotionMaxVelocity(maxFeetPerSec);
    m_pidShooterMotorLead.SetSmartMotionMaxAccel(maxAccelPerSec);
    
    // Set kFF and kP ( after tuning, since gains have been already been determined )
    m_pidShooterMotorLead.SetP(kP);
    m_pidShooterMotorLead.SetFF(kFF);

   // SetHoodHigh();

   // Set up data logging file
   shooterLogger.ShooterLogger("/home/lvuser/ShooterLogs/ShooterLog_" + DataLogger::GetTimestamp() + ".csv");
}

void Shooter::Periodic() {
    if (ShooterEnabled == true) {
        m_pidShooterMotorLead.SetReference(CommandedVelocity, rev::ControlType::kSmartVelocity);
    }
    else {
        m_pidShooterMotorLead.SetReference(0.0, rev::ControlType::kSmartVelocity);
    }

    // Get and write subsystem data to datalog file
    double leadRPM = m_shooterEncoderLead.GetVelocity(); 
    double followRPM = m_shooterEncoderFollow.GetVelocity(); 
    double leadAppliedOutput = m_shooterLead.GetAppliedOutput();
    double followAppliedOutput = m_shooterFollow.GetAppliedOutput();
    double leadVoltage = m_shooterLead.GetBusVoltage();
    double followVoltage = m_shooterFollow.GetBusVoltage();
    double leadCurrent = m_shooterLead.GetOutputCurrent();
    double followCurrent = m_shooterFollow.GetOutputCurrent();
    shooterLogger.WriteShooterData( leadRPM, followRPM, leadAppliedOutput, 
                                    followAppliedOutput, leadVoltage, followVoltage, leadCurrent, followCurrent);
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.
void Shooter::ShooterOff() {
    ShooterEnabled = false;
}

void Shooter::ShooterOn(double velocity) {
    ShooterEnabled = true;
    CommandedVelocity = velocity;
}

void Shooter::SetHoodHigh() {
    m_solHood.Set(frc::DoubleSolenoid::kForward);
}

void Shooter::SetHoodLow() {
    m_solHood.Set(frc::DoubleSolenoid::kReverse);
}

bool Shooter::IsHoodHigh() {
    bool retVal = false;
    
    if (m_solHood.Get() == frc::DoubleSolenoid::kForward) {
        retVal = true;
    }

    return retVal;
}

bool Shooter::IsHoodLow() {
    bool retVal = false;
    
    if (m_solHood.Get() == frc::DoubleSolenoid::kReverse) {
        retVal = true;
    }

    return retVal;
}

void Shooter::EnableLogging() {
    shooterLogger.StartSession();
}

void Shooter::DisableLogging() {
    shooterLogger.EndSession();
}

 